#include <iostream>
//#include <unordered_map>
#include <vector>
//#include <queue>
//#include <algorithm>
#include <string>

using namespace std;

struct realm
{
	// vector <int> magis;
	// string charm;
};

int  maxIncantations(vector <int> magi)
{
	// determine most number of possible steps
}

int minIncantationsBetween(string startingRealm, string endingRealm)
{
	// return minimum number of incantations needed to go start -> end
}

// Dijkstra's Method to determine least heavy path start -> end

bool checkIfPossibleStartToFinish()
{
	// does # steps start to finish == # possible incantations
	// if not, bool is IMPOSSIBLE, print statement in different method
}

void int shortestPath(DirectedWeightedGraph graph)
{
	// cout incantations + " " + gems;
}

// if impossible, make num of incantations = -1 || set minIncantations = -1

int main()
{
  int numOfRealms, numOfMagi, magiPower;
  string charm, startingCharm, destinationCharm;

  cin >> numOfRealms;

  // for number of realms
	cin >> charm;
  	cin >> numOfMagi;

  cin >> startingCharm >> destinationCharm;

 
  return 0;
}
